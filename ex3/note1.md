这段 C 代码将罗马数字转换为整数，**确实用到了哈希表的核心思想**，只是用**数组替代了标准哈希表**。让我详细解释：

## 核心思想：数组作为直接寻址表

```c
int symbolValues[26];  // 26个大写字母的空间
symbolValues['I' - 'A'] = 1;  // 相当于 hash['I'] = 1
symbolValues['V' - 'A'] = 5;  // 相当于 hash['V'] = 5
// ...
```

### 为什么这是哈希思想？

1. **键值对映射**：将字符映射到对应的数值
   - `'I' → 1`, `'V' → 5`, `'X' → 10`...

2. **快速查找**：通过 `s[i] - 'A'` 直接计算索引
   - 时间复杂度 O(1) 的查找，正是哈希表的优势

3. **解决映射关系**：罗马数字规则就是字符到数值的映射

## 如果用标准哈希表实现

```c
// 伪代码展示哈希表版本
int romanToInt_hash(char* s) {
    HashTable ht = createHashTable();
    insert(ht, 'I', 1);
    insert(ht, 'V', 5);
    insert(ht, 'X', 10);
    // ...
    
    for (int i = 0; i < n; i++) {
        int value = search(ht, s[i]);  // 哈希查找
        // 同样处理减法规则
    }
}
```

## 为什么用数组而不用标准哈希表？

1. **键空间很小**：只有 7 个罗马字符（I, V, X, L, C, D, M）
2. **字符连续**：都是大写字母，`'X' - 'A'` 可以直接作为索引
3. **效率更高**：数组访问比哈希表更直接，无哈希冲突
4. **内存可控**：26个int的数组很小（约104字节）

## 减法规则的巧妙处理

```c
if (i < n - 1 && value < symbolValues[s[i+1] - 'A']) {
    ans -= value;  // 如 IV: 先-1，后面会+5
} else {
    ans += value;
}
```

## 总结

这道题体现了**算法思想与具体实现的区别**：
- **算法思想**：确实使用了哈希映射（键值对查找）
- **具体实现**：用数组优化，因为键的特点适合直接寻址

在算法题中，这种"数组代替哈希表"的优化很常见，特别是当键的范围有限且连续时。这仍然是哈希思想的体现，只是实现更高效。
